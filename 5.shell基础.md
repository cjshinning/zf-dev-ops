## shell基础
- shell是一个命令解释器，它为用户提供了一个向linux内核发送请求以便运行程序的界面系统程序
- 用户可以用shell来启动、挂起、停止或者编写一些程序
- shell还是一个功能相对强大的编程语言，易编写，易调试，灵活性较强
- shell是解释执行的脚本语言，在shell中可以直接调用linux系统命令

1. echo
- 输出命令
- -e：激活转义字符
`echo hello`
`echo -e "a\tb"`

2. 编写执行shell
- hello.sh
`#!/bin/bash`
`echo hello`

`sh hello.sh`
`chmod 755 hello.sh`
`chmod u+x hello.sh`
`.hello.sh`

3. 别名
- 命令别名就是小名
- 临时剩下 alias cp="cp -i"
- 写入环境变量配置文件 vi ~/.bashrc
- source ~/.bashrc
- 删除别名 unalias 别名

4. 命令生效顺序
- 绝对路径或者相对路径
- 别名
- bash内部命令
- 按照 $PATH 环境变量定义的目录查找顺序的

5. 命令快捷键
- ctrl+c 强制终止当前命令
- ctrl+l 清屏
- ctrl+a 光标移动到命令行首
- ctrl+e 光标移动到命令行尾
- ctrl+u 光标从所在位置删除到行首

6. 历史命令
- history [选项] [历史命令保存文件]
- 选项
  - -c 清空历史命令
  - -w 把缓存中的历史命令写入历史命令
- 默认保存1000条 /etc/profile HISSIZE=10000

7. 调用
- 使用上下箭头调用以前的历史命令
- 使用 !n 重复执行第n条命令
- 使用 !! 重复执行上一条命令
- 使用 !字符，重复执行最后一条以该字符串开头的命令
`history -c`
`1 echo 1`
`2 echo 2`
`3 echo 3`
`!2`
`!!`
`!echo`

8. 输出重定向
- 标准输入输出
键盘 /dev/stdin 0 标准输入
显示器 /dev/stdout 1 标准输出
显示器 /dev/stderr 2 标准错误输出

- 输入重定向
- wc 命令的功能为统计指令文件中的行数、字数（word count）
- 命令 < 文件把文件做为命令的输入
`wc < a.txt`

9. 管道符号
- 多命令行顺序执行
  - ; 命令1;命令2 多个命令执行，命令直接没有任何逻辑联系 echo1;echo2
  - && 命令1&&命令2 逻辑与，当命令1正确执行，则命令2才会执行，，当命令1执行不正确，则命令2不会执行 echo1&&echo2
  || 命令1||命令2 逻辑或，当命令1正确不执行，则命令2才会执行，，当命令1执行正确，则命令2不会执行 echo1||echo2

- 管道符合
  - 命令1的证书输入会做为命令2的操作对象
  - 命令1|命令2
`ls /etc/ | more`
`netstart -an | grep ESTABLISTED | wc -1`

- 通配符
  - 匹配文件名和目录名
  ? 匹配一个任意字符
  * 匹配0个或任意字符，也就是可以匹配任意内容
  [] 匹配中括号中任意一个字符
  [-] 匹配中括号中任意一个字符，-代表范围
  [^] 匹配不是中括号中的一个字符

- 其他符号
  '' 单引号，在单引号中所有的特殊附后，如$和'都没有特殊含义
  "" 双引号，在双引号里特殊符合都没有特殊含义，但是$ ` \例外，引用命令和转义的含义
  `` 反引号，括起来就是系统命令
  $() 和反引号一样
  # 在shell脚本中，#表示注释
  $ 用于调用变量的值
  \ 转移字符


## 变量
1. 定义
- 可以变化的量
- 变量必须以字母或下划线开头，名字中间只能由字母、数字和下划线组成
- 变量名的长度不得超过255个字符
- 变量名在有效范围内必须唯一
- 变量默认类型都是字符串

2. 变量的分类
- 字符串
- 整形
- 浮点型
- 日期型

3. 用户自定义变量
- 这些变量的值是自己定义的
- 变量名不能为数字开头
- 等号左右两边不能有空格

- 3.1 定义变量
`name=jenny`
`age=10`

- 3.2 输出变量值
`$ x=1`

- 3.3 set
  - 查询系统中默认变量

- 3.4 unset
  - 删除变量


## 环境变量
- 环境变量是全局变量，而自定义变量是局部变量
- 自定义变量会在当前的shell中生效，而环境变量会在当前shell以及子shell中生效
- 这种变量主要保存的是和系统操作相关的数据
- 变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的

`bash`
`pstree`

1. 自定义环境变量
`export 变量名=变量值`
`export envname=prod`

2. env
- 仅仅用来查看环境变量，而不看到本地变量
`env`

3. 常用环境变量
HOSTNAME 主机名 HOSTNAME=localhost
SHELL 当前的shell SHELL=/bin/bash
TERM  终端环境  TERM=xterm
HISTSIZE  历史命令条数  HISTSIZE=1000
SSH_CLIENT 当前操作环境如果是SSH链接的话，这里会记录客户端IP  SSH_CLIENT=192.168.1.100 57596 22
SSH_TTY SSH链接的终端 SSH_TTY=/dev/pts/1
USER  当前登录的用户  USER=root

4. path
- 系统搜索路径
`echo $PATH`

5. $PS1

6. 语系环境变量
`locale`
`LANG=en_US.UTF-8`
`echo $LANG`
`en_US.UTF-8`

7. 中文支持


## 位置参数变量
- 这种变量主要是用来向脚本当中传递参数或数据的，变量名不能自定义，变量作用是固定的

<!-- 位置参数变量 作用
$n n为数字，$0代表命令本身，$1-9代表1-9个参数，10以上的参数需要用大括号包含，如${10}
$* 这个变量代表命令中所有的参数，$*把所有变量看出一个整体
$@ 这个变量也代表命令中所有的参数，不过$@把每个参数进行区分
$# 这个变量代表命令中所有参数的个数 -->


## 预定义变量

## read
- read [选项] [变量名]
选项 含义
-p 提示信息，在等待read输入时，输出提示信息
-t 秒数：read命令会一直等待用户输入，使用此项可以指定等待时间
-n 字符串，read命令指介绍知道的字符数，就会执行
-s 因此输入的数据，适用于机密信息的输入


## 运算符
### declare命令
1. declare命令
- 用来声明变量类型
- declare(+/-) [选项] 变量名
选项 含义
- 给变量设定类型属性
+ 取消变量的类型属性
-a 将变量声明为数组类型
-i 将变量声明为整数型
-x 将变量声明为环境变量
-r 将变量声明为只读变量
-p 显示指定变量的被声明类型

`delcare -r x`  //只读

2. 数组
`declare -a names`

3. 声明环境变量
- export最终执行的是declare -x 命令
- declare -p 可以查看所有类型
`export NAME=jenny`
`declare -x NAME=jenny`

4. 只读属性

5. 查询变量熟悉

### 数值运算的方法
- 只要用declare声明的变量的时候知道类型就可以进行数值运算
1. export或let
- 符号左右两边必须有空格，否则还是整块输出

2. 优先级

## 环境变量配置文件
1. source命令
- 修改完配置文件后，必须注销重新登录才生效，使用source命名可以不用重新登录
- source配置文件

2. 环境变量文件简介
- PATH、HISTSIZE、PS1、HOSTNAME等变量写入对应的环境变量配置文件
- 环境变量配置文件中主要是定义系统操作环境生效的系统默认环境变量，如PATH等文件登录时起作用的环境变量
系统变量，针对所有用户生效：
/etc/profile  //针对所有的shell，比如主机名、用户名
/etc/bashrc //只是针对bash生效的
当前变量，针对当前用户生效：
~/.bash_profile 只会对当前用户生效  //针对当前的shell，比如主机名、用户名
~/.bashrc 指会对当前用户生效  //只是针对bash生效的

3. 环境变量配置文件的功能
3.1 /etc/profile
- 在这里修改系统变量
cat /etc/profile | grep USER
USER 用户名
LOGNAME 登录名
MAIL 邮箱地址
PATH 查找路径
HOSTNAME 主机名
umask 权限掩码

3.2 ~/.bash_profile
- 在这里修改PATHA路径
- 调用 ~/.bashrc

3.3 ~/.bashrc
- 在这里改别名，配置alias
- 调用 /etc/bashrc

3.4 /etc/bashrc
- PS1 登录提示符在这里修改
- umask
- PATH 变量
- 调用 /etc/profile_d/*.sh文件

3.5 其他配置
3.5.1 注销时生效的环境变量配置文件
- ~/.bash_logout

3.5.2 历史脚本
- ~/.bash_history

3.5.3 shell登录信息

## 正则表达式
5. cut
- cut用来提取文件中的某一部分文本
- cut [选项] 文件名
  - -f 列号，用来指定要提取的列
  - -d 分隔符，按照指定分隔符风格列，默认分隔符是TAB制表符
  提取用户名和它使用的shell
  `cat /etc/passwd | cut -f 1,7 -d`

6. printf 
- 按规定格式输出
- printf 输出类型 输出内容

7. awk
- awk '条件1（动作1）条件2（动作2）...' 文件名
- 条件
  - 一般使用关系表达式做为条件
  - x>10 判断变量x是否大于10
  - x>=10 大于等于
  - x<=10 小于等于

- 动作
  - 格式化输出

8. sed命令
- sed是一个轻量级编辑器，主要用来对数据进行选取、替换和新增操作
- sed [选项] [动作] 文件名
- 所有的动作都必须用单银行括起来
- 类型类似于批量vi操作

8.1 动作
a 追加，在每一行或者指定行下面加一行或多厚
c 行替换，用c后面的字符串还掉原始整个数据行
s 字符串替换，用一个字符串替换另外一个字符串
i 插入，在当前行插入一行或多行
d 删除定制的行
p 打印，输出指定的行

8.2 选项
-n 一般sed命令会吧所有数据都输出到屏幕上，如果假如此选项只会把处理过的输出到屏幕上
-e 允许对输入数据应用多条sed编辑命令
-i 用sed的修改直接修改编辑的文件，而不是屏幕上输出

9. sort 排序命令
- sort [选项] 文件名
- 选项
-f 忽略大小写
-n 移数值进行排序
-r 反向排序
-t 指定分割符
-k,n 按照知道的字段范围


## 流程控制
1. 流程控制
1.1 按照
选项 含义
-d 文件是否存在并且是目录
-e 文件是否存在
-f 文件是否存在并且是普通文件
-b 文件是否存在并且是块设备文件(block)
-c 文件是否存在并且是字符设备文件(char)
-L 文件是否存在并且是链接文件
-p 文件是否存在并且是管道文件(pipe)
-s 文件是否存在并且是否为空
-S 文件是否存在并且是套接字文件(Socket)

`test -e 1.txt`
`[-e 1.txt]`
`echo $?`

1.2 安装文件权限进行
选项 含义
-r 文件是否存在，并且是否用于读权限
-w 文件是否存在，并且是否用于写权限
-x 文件是否存在，并且是否用于执行权限

1.3 两个文件间进行比较
文件1 -nt 文件2 判断文件1的修改时间是否比文件2的新
文件1 -ot 文件2 判断文件1的修改时间是否比文件2的旧
文件1 -ef 文件2 判断文件1和文件2的inode号是否一致，可用于判断硬链接

1.4 两个整数间的比较

1.5 字符串判断
-z 字符串 判断字符串是否为空
-n 字符中 判断字符串是否为非空
字符串1==字符串2  判断字符串1是否和字符串2相等
字符串1！=字符串2 判断字符串1是否和字符串2不相等

1.6 多重条件判断
判断1 -a 判断2 逻辑与
判断1 -o 判断2 逻辑或
!判断 逻辑非

2. 单分支if语句
- if语句使用 fi 结尾
- [条件判断式]就是使用 test 命令进行判断，所以中括号和条件判断式之间必须有空格
- then后面跟符合条件之后执行的程序，可以放在[]之后，用;分隔，也可以换行，不用;

2.1 语法
`if [ 条件判断 ];then`
  `代码体`
`fi`

注：usr：Unix System Resource（Unix系统资源库）

6. for循环
6.1 语法
`for 变量 in 值1 值2 值3
do
代码块
done`

7. while循环

8. util循环

## 函数
- linux shell 可以用户定义函数，然后再shell脚本中可以随便使用
- 可以带function fun()定义，也可以直接fun()定义，不带任何参数
- 调用函数不需要加()

1. 简单函数

2. 返回值

3. 参数说明
<!-- 参数处理 说明
$# 传递到脚本的参数个数
$* 以一个单字符串显示所有想脚本传递的参数
$@ 与$*相同，但是使用时加引号，并在引号中返回每个参数
$$ 脚本运行的当进程id号
$! 后台运行的最后一个进程的id号
$- 显示shell使用的当前选项，与set命名功能相同
$? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误 -->

4. profile
4.1 脚本

4.2 打印当前脚本